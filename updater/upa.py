b'__version__="1.0.0"\n\nimport traceback\n\ndef update(dl_url, force_update=False):\n    """\nAttempts to download the update url in order to find if an update is needed.\nIf an update is needed, the current script is backed up and the update is\nsaved in its place.\n"""\n    import urllib\n    import urllib.request\n    import re\n    import os,sys\n    from subprocess import call\n    def compare_versions(vlocal, vremote):\n        \n        if vlocal == vremote: return 0\n        \n        def isfloat(s):\n            try:\n                float(s)\n            except ValueError:\n                return False\n            return True\n        \n        vlocal=vlocal.replace(\'.\',\'\')\n        vremote=vremote.replace(\'.\',\'\')\n        \n        if isfloat(vlocal) and isfloat(vremote):\n            if float(vlocal) > float(vremote):\n                return 1\n            else:\n                return -1\n        else:\n            print("lool %s und %s" % (str(vlocal),str(vremote)))\n            return 0\n        \n    # dl the first 256 bytes and parse it for version number\n    try:\n        http_stream = urllib.request.urlopen(dl_url)\n        update_file = http_stream.read(256)\n        http_stream.close()\n    except Exception as e:\n        print(e)\n        traceback.print_exc()\n        return\n\n    match_regex = re.search(r\'__version__ *= *"(\\S+)"\', str(update_file))\n    if not match_regex:\n        print("No version info could be found")\n        return\n    update_version = match_regex.group(1)\n\n    if not update_version:\n        print("Unable to parse version data")\n        return\n\n    if force_update:\n        print("Forcing update, downloading version %s..." \\\n            % update_version)\n    else:\n        cmp_result = compare_versions(__version__, update_version)\n        if cmp_result < 0:\n            print("Newer version %s available, downloading..." % update_version)\n        elif cmp_result > 0:\n            print("Local version %s newer then available %s, not updating." \\\n                % (__version__, update_version))\n            return\n        else:\n            print("Local version %s equal to available %s, not updating." \\\n                % (__version__, update_version))\n            return\n\n    # dl, backup, and save the updated script\n    app_path = os.path.realpath(sys.argv[0])\n\n    if not os.access(app_path, os.W_OK):\n        print("Cannot update -- unable to write to %s" % app_path)\n\n    dl_path = app_path + ".new"\n    backup_path = app_path + ".old"\n    try:\n        dl_file = open(dl_path, \'w\')\n        http_stream = urllib.request.urlopen(dl_url)\n        total_size = None\n        bytes_so_far = 0\n        chunk_size = 8192\n        try:\n            total_size = int(http_stream.info().get(\'Content-Length\').strip())\n        except:\n            # The header is improper or missing Content-Length, just download\n            dl_file.write(str(http_stream.read()))\n\n        while total_size:\n            chunk = http_stream.read(chunk_size)\n            dl_file.write(str(chunk))\n            bytes_so_far += len(chunk)\n\n            if not chunk:\n                break\n\n            percent = float(bytes_so_far) / total_size\n            percent = round(percent*100, 2)\n            sys.stdout.write("Downloaded %d of %d bytes (%0.2f%%)\\r" %\n                (bytes_so_far, total_size, percent))\n\n            if bytes_so_far >= total_size:\n                sys.stdout.write(\'\\n\')\n\n        http_stream.close()\n        dl_file.close()\n    except Exception as e:\n        print(e)\n        traceback.print_exc()\n        return\n\n    try:\n        os.rename(app_path, backup_path)\n    except Exception as e:\n        print(e)\n        traceback.print_exc()\n        return\n\n    try:\n        os.rename(dl_path, app_path)\n    except Exception as e:\n        print(e)\n        traceback.print_exc()\n        return\n\n    try:\n        import shutil\n        shutil.copymode(backup_path, app_path)\n    except Exception as e:\n        print(e)\n        traceback.print_exc()\n        os.chmod(app_path, \'0755\')\n\n    print("New version installed as %s" % app_path)\n    print("(previous version backed up to %s)" % (backup_path))\n    \n    python = sys.executable\n    os.execl(python, python, * sys.argv)\n    os.execl(sys.executable, sys.executable, *sys.argv) \n    \n    return\n    \n    \n    \nupdate(\'https://github.com/boba2fett/ShitCollection/raw/master/updater/up.py\')\n'b''